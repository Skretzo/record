<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Record</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 20px; max-width: 820px; margin: auto; }
    .mode { display:flex; gap:12px; margin-top:8px; align-items:center; }
    label { display:inline-flex; gap:8px; align-items:center; cursor:pointer; }
    button { margin-right:8px; margin-top:12px; }
    video, audio { display:block; margin-top:12px; max-width:100%; border:1px solid #ddd; }
    .status { margin-top:12px; font-weight:600; }
  </style>
</head>
<body>
  <h3>Record</h3>

  <div>
    <label><input type="radio" name="mode" value="audio" checked /> Only audio (microphone)</label><br>
    <label><input type="radio" name="mode" value="video" /> Only video (screen)</label><br>
    <label><input type="radio" name="mode" value="both" /> Video and audio (screen and microphone)</label>
  </div>

  <div>
    <label><input type="checkbox" id="combineAudio" checked /> Combine screen and microphone audio</label>
  </div>

  <div>
    <button id="startBtn">Start recording</button>
    <button id="stopBtn" disabled>Stop recording</button>
  </div>

  <div class="status" id="status">Idle</div>
  <a id="downloadLink" style="display:none">Download recording</a>
  <a id="downloadLinkExtra" style="display:none">Download microphone recording</a>

  <video id="preview" autoplay muted playsinline style="display:none;"></video>
  <audio id="playbackAudio" controls style="display:none;"></audio>
  <video id="playbackVideo" controls style="display:none;"></video>

  <script>
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusEl = document.getElementById('status');
    const preview = document.getElementById('preview');
    const downloadLink = document.getElementById('downloadLink');
    const downloadLinkExtra = document.getElementById('downloadLinkExtra');
    const playbackAudio = document.getElementById('playbackAudio');
    const playbackVideo = document.getElementById('playbackVideo');
    const combineAudio = document.getElementById('combineAudio');

    let micStream = null;
    let screenStream = null;
    let mixedStream = null;
    let mediaRecorder = null;
    let mediaRecorderExtra = null;
    let recordedChunks = [];
    let recordedChunksExtra = [];
    let recordingMime = '';

    function updateStatus(t) { statusEl.textContent = t; }

    function getSelectedMode() {
      const r = document.querySelector('input[name="mode"]:checked');
      return r ? r.value : 'audio';
    }

    const preferredTypes = [
      'video/mp4',
      'video/webm;codecs=vp9,opus',
      'video/webm;codecs=vp8,opus',
      'video/webm;codecs=vp8',
      'video/webm',
      'audio/mp4',
      'audio/webm'
    ];

    const preferredTypesExtra = [
      'audio/mp4',
      'audio/webm'
    ];

    function chooseMime() {
      for (const t of preferredTypes) {
        if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
      }
      return '';
    }

    function chooseMimeExtra() {
      for (const t of preferredTypesExtra) {
        if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
      }
      return '';
    }

    function buildMixedStream(screen, mic, mode, combine) {
      const out = new MediaStream();

      if (mode === 'audio') {
        if (mic) mic.getAudioTracks().forEach(t => out.addTrack(t));
        return [out];
      }

      if (mode === 'video') {
        if (screen && screen.getVideoTracks().length) screen.getVideoTracks().forEach(t => out.addTrack(t));
        // include screen audio if provided by getDisplayMedia
        if (screen && screen.getAudioTracks().length) screen.getAudioTracks().forEach(t => out.addTrack(t));
        return [out];
      }

      // both
      if (screen && screen.getVideoTracks().length) screen.getVideoTracks().forEach(t => out.addTrack(t));

      // combine screen and voice audio if both are available (having 2 separate tracks does not work)
      if (screen && mic && screen.getAudioTracks().length && mic.getAudioTracks().length) {
        if (combine) {
          const audioContext = new AudioContext();
          const combined = audioContext.createMediaStreamDestination();

          audioContext.createMediaStreamSource(screen).connect(combined);
          audioContext.createMediaStreamSource(mic).connect(combined);

          combined.stream.getAudioTracks().forEach(t => out.addTrack(t));

          return [out];
        } else { // make an extra audio file for the microphone
          const outExtra = new MediaStream();
          screen.getAudioTracks().forEach(t => out.addTrack(t));
          mic.getAudioTracks().forEach(t => outExtra.addTrack(t));
          return [out, outExtra]
        }
      }

      // include screen audio if available
      if (screen && screen.getAudioTracks().length) screen.getAudioTracks().forEach(t => out.addTrack(t));
      // include mic audio
      if (mic && mic.getAudioTracks().length) mic.getAudioTracks().forEach(t => out.addTrack(t));

      return [out];
    }

    function stopAllStreams() {
      [micStream, screenStream, mixedStream].forEach(s => {
        if (s) s.getTracks().forEach(t => {
          try { t.stop(); } catch (e) {}
        });
      });
      micStream = screenStream = mixedStream = null;
    }

    function hookDisplayEnd(display) {
      if (!display) return;
      display.getVideoTracks().forEach(track => {
        track.addEventListener('ended', () => {
          if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        });
      });
      display.getAudioTracks().forEach(track => {
        track.addEventListener('ended', () => {
          if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        });
      });
    }

    startBtn.addEventListener('click', async () => {
      recordedChunks = [];
      recordedChunksExtra = [];
      mediaRecorderExtra = null;
      recordingMimeExtra = null;
      dateString = null;
      downloadLink.style.display = 'none';
      downloadLinkExtra.style.display = 'none';
      playbackVideo.style.display = 'none';
      playbackVideo.src = '';
      playbackAudio.style.display = 'none';
      playbackAudio.src = '';
      preview.style.display = 'none';
      preview.srcObject = null;
      updateStatus('Requesting permissions...');

      const mode = getSelectedMode();

      // Request mic only if needed
      try {
        if (mode === 'audio' || mode === 'both') {
          micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        } else {
          micStream = null;
        }
      } catch (err) {
        updateStatus('Microphone access denied or unavailable: ' + (err && err.message ? err.message : err));
        return;
      }

      // Request screen if needed
      try {
        if (mode === 'video' || mode === 'both') {
          // audio:true here allows capturing system audio on platforms that support it
          screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
          hookDisplayEnd(screenStream);
        } else {
          screenStream = null;
        }
      } catch (err) {
        if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
        updateStatus('Screen capture denied or unavailable: ' + (err && err.message ? err.message : err));
        return;
      }

      // Build the stream we will feed MediaRecorder
      const mixedStreamTuple = buildMixedStream(screenStream, micStream, mode, combineAudio.checked);
      mixedStream = mixedStreamTuple[0];

      // Show preview for video modes
      if ((mode === 'video' || mode === 'both') && screenStream && screenStream.getVideoTracks().length) {
        preview.style.display = '';
        preview.srcObject = screenStream;
      } else {
        preview.style.display = 'none';
      }

      // Choose mime
      recordingMime = chooseMime();
      const recorderOptions = recordingMime ? { mimeType: recordingMime } : undefined;

      try {
        mediaRecorder = new MediaRecorder(mixedStream, recorderOptions);
        if (mixedStreamTuple.length > 1) {
          recordingMimeExtra = chooseMimeExtra();
          mediaRecorderExtra = new MediaRecorder(mixedStreamTuple[1], { mimeType: recordingMimeExtra });
        }
      } catch (err) {
        updateStatus('MediaRecorder initialization failed: ' + (err && err.message ? err.message : err));
        stopAllStreams();
        return;
      }

      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) recordedChunks.push(e.data);
      };

      mediaRecorder.onstart = () => {
        updateStatus('Recording...');
        startBtn.disabled = true;
        stopBtn.disabled = false;
      };

      mediaRecorder.onstop = async () => {
        updateStatus('Stopped recording');
        startBtn.disabled = false;
        stopBtn.disabled = true;

        // Stop streams
        stopAllStreams();

        const blobType = recordingMime || (mode === 'audio' ? 'audio/webm' : 'video/webm');
        const blob = new Blob(recordedChunks, { type: blobType });

        // Playback
        if (mode === 'video' || mode === 'both') {
          preview.style.display = 'none';
          playbackVideo.style.display = '';
          playbackVideo.src = URL.createObjectURL(blob);
          playbackAudio.style.display = 'none';
        } else {
          playbackAudio.style.display = '';
          playbackAudio.src = URL.createObjectURL(blob);
        }

        // Save
        const ext = (recordingMime && recordingMime.includes("mp4")) ? 'mp4' : 'webm';
        dateString = new Date().toISOString().replace(/[:.]/g,'-');
        const suggestedName = `recording-${dateString}.${ext}`;
        downloadLink.style.display = '';
        downloadLink.href = URL.createObjectURL(blob);
        downloadLink.download = suggestedName;
        downloadLink.click();
        setTimeout(() => {
          URL.revokeObjectURL(downloadLink.href);
        }, 60 * 1000);
      };

      if (mediaRecorderExtra !== null) {
        mediaRecorderExtra.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) recordedChunksExtra.push(e.data);
        };

        mediaRecorderExtra.onstop = async () => {
          const blobExtra = new Blob(recordedChunksExtra, { type: recordingMimeExtra });

          playbackAudio.style.display = '';
          playbackAudio.src = URL.createObjectURL(blobExtra);

          // Save
          const extExtra = (recordingMimeExtra && recordingMimeExtra.includes("mp4")) ? 'mp4' : 'webm';
          const suggestedNameExtra = `recording-microphone-${dateString}.${extExtra}`;
          downloadLinkExtra.style.display = '';
          downloadLinkExtra.href = URL.createObjectURL(blobExtra);
          downloadLinkExtra.download = suggestedNameExtra;
          //downloadLinkExtra.click();
          setTimeout(() => {
            URL.revokeObjectURL(downloadLinkExtra.href);
          }, 60 * 1000);
        };
      }

      mediaRecorder.start();
      if (mediaRecorderExtra !== null) mediaRecorderExtra.start();
    });

    stopBtn.addEventListener('click', () => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      if (mediaRecorderExtra && mediaRecorderExtra.state !== 'inactive') mediaRecorderExtra.stop();
    });

    window.addEventListener('beforeunload', () => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      if (mediaRecorderExtra && mediaRecorderExtra.state !== 'inactive') mediaRecorderExtra.stop();
      stopAllStreams();
    });
  </script>
</body>
</html>
