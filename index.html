<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebM Opus Recorder</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 24px; max-width: 720px; margin: auto; }
    button { margin: 8px 8px 8px 0; padding: 10px 14px; font-size: 14px; }
    #status { margin-top: 12px; color: #333; }
    #downloadLink { display:block; margin-top:12px; }
  </style>
</head>
<body>
  <h3>Audio Recorder audio/webm Opus</h3>

  <p>
    <button id="requestMic">Request Microphone</button>
    <button id="startBtn" disabled>Start Recording</button>
    <button id="stopBtn" disabled>Stop & Save</button>
  </p>

  <div id="status">Microphone not requested.</div>
  <a id="downloadLink" style="display:none">Download recording</a>

  <script>
    // Elements
    const requestMicBtn = document.getElementById('requestMic');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const status = document.getElementById('status');
    const downloadLink = document.getElementById('downloadLink');

    // State
    let mediaStream = null;
    let mediaRecorder = null;
    let chunks = [];
    const MIME_TYPE = 'audio/webm;codecs=opus';

    // Request microphone permission and prepare stream
    requestMicBtn.addEventListener('click', async () => {
      try {
        status.textContent = 'Requesting microphone permission...';
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        status.textContent = 'Microphone ready. You can start recording.';
        startBtn.disabled = false;
      } catch (err) {
        console.error('getUserMedia error', err);
        status.textContent = 'Microphone access denied or error occurred.';
      }
    });

    // Start recording
    startBtn.addEventListener('click', () => {
      if (!mediaStream) {
        status.textContent = 'No microphone stream available. Click Request Microphone first.';
        return;
      }
      // Ensure requested MIME type is supported
      if (!MediaRecorder.isTypeSupported(MIME_TYPE)) {
        status.textContent = `Desired MIME type ${MIME_TYPE} not supported in this browser.`;
        // Still try with default if possible
      }
      try {
        chunks = [];
        mediaRecorder = new MediaRecorder(mediaStream, { mimeType: MIME_TYPE });
      } catch (err) {
        // fallback: try without explicit mimeType
        try {
          mediaRecorder = new MediaRecorder(mediaStream);
        } catch (err2) {
          console.error('MediaRecorder creation failed', err2);
          status.textContent = 'Unable to create MediaRecorder on this browser.';
          return;
        }
      }

      mediaRecorder.ondataavailable = e => {
        if (e.data && e.data.size > 0) chunks.push(e.data);
      };

      mediaRecorder.onstart = () => {
        status.textContent = 'Recording...';
        startBtn.disabled = true;
        stopBtn.disabled = false;
        requestMicBtn.disabled = true;
        downloadLink.style.display = 'none';
      };

      mediaRecorder.onstop = async () => {
        status.textContent = 'Recording stopped. Preparing file...';
        const blob = new Blob(chunks, { type: MIME_TYPE });
        await saveBlobToFile(blob);
        status.textContent = 'File saved or download ready.';
        startBtn.disabled = false;
        stopBtn.disabled = true;
        requestMicBtn.disabled = false;
      };

      mediaRecorder.onerror = ev => {
        console.error('MediaRecorder error', ev);
        status.textContent = 'Recording error occurred.';
      };

      mediaRecorder.start();
    });

    // Stop recording and save
    stopBtn.addEventListener('click', () => {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      } else {
        status.textContent = 'No active recording to stop.';
      }
    });

    // Save using File System Access API if available, else fallback to anchor download
    async function saveBlobToFile(blob) {
      const defaultName = `recording-${new Date().toISOString().replace(/[:.]/g,'-')}.webm`;
      // File System Access API (showSaveFilePicker)
      if (window.showSaveFilePicker) {
        try {
          const opts = {
            suggestedName: defaultName,
            types: [{
              description: 'WebM audio',
              accept: { 'audio/webm': ['.webm'] }
            }]
          };
          const handle = await window.showSaveFilePicker(opts);
          const writable = await handle.createWritable();
          await writable.write(blob);
          await writable.close();
          return;
        } catch (err) {
          console.error('showSaveFilePicker error or aborted', err);
          // Fall through to fallback download
        }
      }

      // Fallback: create object URL and provide a download link
      const url = URL.createObjectURL(blob);
      downloadLink.href = url;
      downloadLink.download = defaultName;
      downloadLink.textContent = 'Click here to download the recording';
      downloadLink.style.display = 'inline-block';
      // Optionally auto-click to start download immediately:
      // downloadLink.click();
      // Revoke URL after some time
      setTimeout(() => URL.revokeObjectURL(url), 60 * 1000);
    }

    // Clean up when page unloads
    window.addEventListener('beforeunload', () => {
      if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
      }
    });
  </script>
</body>
</html>
